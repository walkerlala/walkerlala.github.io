### $\blacksquare$ 关于Reliable Data Transimission(RDT): GBN、SR、TCP

### (GBN)Go-Back-N 回退N步

- GBN receiver无须暂存任何顺序步正确的packet，因为sender会重新发送所有未经确认的packet
- GBN的单一packet错误(比如没有在timeout之前接收到ack)将导致重送大量无须重送的packet

##### \#, GBN发送端

- 累积式确认：收到接收端回传的ACK(n)，即表示序号小于n的packet都已经正确收到了。
- 使用一个 Timer：绑定最早发出且未经确认的packet (base)
- 超时行为：Timeout 前都还没收到最早发送出的packet所回传的ACK，则重新发送所有未经确认的packet (base ~ nextseqnum-1)
- 收到顺序不正确的ACK：不做任何事情
- **收到顺序不正确的ACK：不做任何事情**(这个我怀疑。我觉得收到顺序不正确的ACK分为两种情况：如果这个ACK以前就收到了，那么就不处理；但是如果这个ACK是对一个比较靠后的n进行的确认，那么这个n以前的packet都获得了确认)
- 收到顺序正确的ACK：
  - 将base设为ACK序号+1，造成窗口滑动(因此这个协议又称为**窗口滑动协议**)
  - 若还有packet可传送，重新启动Timer，并传送新的packet

##### \#, GBN接收端

- 收到正确顺序的packet：回传该packet序号的ACK给传送端
- 收到错误顺序的packet：回传最后一次收到正确序号的ACK给传送端

### SR(Selective Repeat) 选择重传

- SR传送端只重新发送接收端未正确收到的packet

- SR会将失序的packet缓存

- SR的传送端、接收端双方的window位置各不相同

- SR窗口的大小不许等于有限序号大小的一半

  $$\blacksquare$$ *为什么窗口大小必须是序号大小的一半呢*

  - 假设有限序号０、１、２、３，窗口大小为３。如果此时接收端收到0, 1, 2，则接收端窗口观点会从[0, 1, 2] , 3 , 0, 1, 2, 3...变成0, 1, 2, [3, 0, 1], 2, 3, 假设这时候接收端回传给传送端的ACK遗失从而造成传送端Timeout而重发第一批的0, 1, 2，而此时接收端想要的却是第一批的0, 1....这就尴尬了
  - 同样的情境，将窗口大小改为2, 接收端收到0, 1, 则接收端窗口会从[0, 1], 2, 3, 0, 1, 2, 3 变成 0, 1, [2, 3], 0, 1, 2, 如果同样发生接收端回传的ACK遗失，传送端等待超时从而重传第一批的0, 1，这时候接收端就不会有错乱的问题了。

##### \#, SR 传送端

- 超时事件：每个packet都已自己的Timer，当各个packet的ACK都超时时，则重新发送该packet
- 收到ACK：
  1. 标记对应序号的packet为已经确认
  2. 若收到的ACK序号是base，则将base移动到下一个最小未经确的packet上
  3. 若窗口移动到了尚未传送的packet上，则同时传送这些未被传送的packet

##### \#, SR 接收端

- 接收到目前window内任何一个packet：
  1. 回传收到的序号的ACK给传送端
  2. 若收到的序号不是base，则将packet缓存
  3. 若收到的序号是base，从base与其后连续已收到的packet交给上层，并将window移动到最小预期收到的位置上。例如：接收端窗口为0, 1, 2, 3, 4, 此时收到1, 2, 3, 将他们缓存起来，之后收到base, 则将0, 1, 2, 3交给上层，并将window移动到 4
- 收到window之前的packet：立刻回传（如果不传，传送端的窗口可能无法移动）
- 收到其他packet：忽略

### TCP (Transmission Control Protocol)

- TCP 传送端只需要维护「最小已经发出未经确认的packet的序号」以及「下一个要传送的packet的序号」
- TCP对一次 Timeout 最多只重发一个packet
- TCP的ACK与GBN、SR的ACK不同，TCP传送端所发出的ACK，表示期待下一次要收到的packet的序号，而GBN、SR是用了确认已经收到的packet的序号
- TCP同SR一样会将失序的packet缓存（其实TCP的RFC里面并没有要求这个行为，但是大多数的TCP实现都是这样做的）
- TCP为累积式确认（也有某种TCP修正称为选择性确认）

##### \#, TCP 传送端

- 超时：重发packet
- 定时地在某些特定的时刻对网络状态做估计，得到估计时延（EstimatedRTT），用来设置定时器的TimerInterval
- 加倍时间间隔：每次TCP重传都会将下一次的超时间隔设为先前的两倍
- 收到重复三次的ACK（Duplicate ACK）：重发packet，又称**快速重传**

##### \#, TCP 接收端

- 预期packet抵达：回传下一次期望收到的packet的ACK
- 非预期的packet抵达：暂存packet，送出期望收到的packet的序号的ACK

### $\blacksquare$ 为什么TCP连接需要三次握手

TCP作为一种可靠数据传输协议，其核心思想是：既要保证数据可靠传输，又要提高传输的效率，用三次恰恰可以满足以上两方面的要求。

1. 可靠传输

   TCP连接的一方A, 由操作系统动态随机选取一个32位长的序列号(ISN, Initial Seqeunce Number)，假设A的初始序列号为1000, 以该序列号为原点，对自己将要发送的每个字节的数据进行编号，10001，10002，10003...，并吧自己的初始序列号ISN告诉B，让B有一个思想准备，什么样的数据是合法的，什么编号是非法的（比如编号900就是非法的，同时B还可以对A的每一个编号的字节数据进行确认。如果A收到B的确认编号为20001，则意味着字节编号10001~20000的字节都已经安全到达。

   同理B也是类似的操作，假设B的初始化序号ISN为2000，以改序列号为原点，对自己将要发送的每个字节的数据进行编号，2001, 2002, 2003..., 并把自己的初始化序号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A的确认编号为4001，则意味着字节编号2001~4000共2000个字节已经安全到达。

   一句话，TCP握手，握的是双方数据原点的序列号。

2. 在可靠数据传输上做到高效率

   **假设TCP是四次握手**

   2.1. A 发送同步信号SYN + A's Initial sequence number

   2.2 B 确认收到A的同步信号，并记录A的ISN到本地，回送ACK sequence number

   2.3 B发送同步信号 SYN + B's Initial sequence number

   2.4 A确认收到B的同步信号，并记录B's ISN到本地, 回送 ACK sequencenumber

   很显然，2.2和2.3可以合并

   **假设TCP是二次握手**

   2.1 A发送同步信号SYN + A's ISN

   2.2 B发送ACK + 同步信号SYN + B's ISN

   这里有一个问题，A与B就A的初始化序列达成了一致，但是B无法知道A是否已经接收到了自己的同步信号，如果这个同步信号丢失了，A和B就B的同步信号将无法达成一致。

   ------

   所以，综上所述，TCP应该为三次握手。

   （如果A发给B的确认丢失了，该如何? B如果没有收到A的ACK，将会超时重传自己的SYN同步信号，一直到收到A的ACK为止）

   从另外一个方面讲，**这个问题的本质是，信道不可靠，但是通信双方需要就某个问题达成一致，而需要解决这个问题，无论你在消息中包含什么信息，三次通信是理论上的最小值。所以三次握手不是TCP本身的要求，而是为了满足"在不可靠信道上可靠地传输信息"这一需求导致的**

   ---

   Bonus, 三次握手中各种packet丢失的情况及其处理手段：

   - 第一个包，即A发给B的SYN中途被丢

     A会周期性超时重传，直到收到B的确认

   - 第二个包，即B发给A的SYN+ACK中途丢失，没有到达A

     B会周期性超时重传，直到收到A的确认

   - 第三个包，即A发给B的ACK中途被丢，没有到达B

     A发完ACK，单方面认为TCP为Established状态，而B显然认为TCP为Actived状态

     - 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP连接也为Established状态，双方可以发包
     - 假定此时A有数据发送，B收到A的 data + ACK, 自然会切换为 Established 状态，并接受 A 的 data
     - 假设B有数据发送，则数据发送不了，会一直周期性重传 SYN + ACK, 直到收到 A 的确认才可以发送数据

   #### 为什么断开连接需要四次握手?

   因为TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机１发出`FIN`报文段时，只是表示主机１已经没有数据要发送了，主机１告诉主机２，他的数据已经全部发送完毕了，但是这个时候主机１还是可以接受主机２的数据；当主机２也发送`FIN`报文段时，表示它已经知道主机１没有数据要发送了，但是主机２还是可以发送数据到主机１的；当主机２也发送了`FIN`报文段时，才表示主机２也没有数据要发送了，就会告诉主机１,,,于是愉快地中断这次TCP连接。

