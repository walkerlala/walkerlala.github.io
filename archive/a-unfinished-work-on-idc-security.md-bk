## A Unfinished Work on IDC Security

TL;DR: 

>  I want to put here [a *unfinished* paper](../pub/km.pdf) which describe a project I was involved when I was an intern at Baidu Inc. Some of the techniques described in that is very interesting and might inspire people. (Please ignore section 6 and 7)

In the last few months I was in Baidu Inc. as a intern, working on the security department. I was mainly involved in a project that aims to audit users behaviors in IDC (Internet Datacenter). Specifically, we wanted to know what a user do with a piece of data and whether or not are those data get stolen. This project is similar with the [*linux-audit*](https://github.com/linux-audit) project, except that we had more control to the models we used and more compatibility (the kernels deployed in the IDC are pretty old and the corresponding *linux-audit* version contains many bugs). 

I worked on that project for several months and worked out many cool things. Technically what we were doing is to intercept system calls. On Linux, every operation get down to a few system calls. For example, to read a file, you have to use the `read(2)` syscall; to write to a file, the `write(2)` syscall; to connect to a remote server, a `connect(2)` syscall, etc. Therefore, if one can intercept all the relevant syscalls, you know exactly what happen, e.g., who read those data and how that data get transfered. And what make this really great is that in Baidu we already have a system that associates **real user name** with **uid** in a host. That says, if you know which *uid* does what to which piece of data, you know which person (in real) does what to which piece of data.

To intercept syscalls, one can write a driver and plug it into the kernel. That is what *linux-audit* does. But writing a kernel driver requires advanced skills and maybe a longterm painful maintenance. Fortunately, nearly all syscalls were invoked through *libc*, which means that you can just write some hooks and play with the dynamic linker (*ld.so*) so that whenever a syscall is invoked (through *libc*), your hook get invoked. And inside your hook, you can get any information related to that process, i.e., which user started this process at which time and what it does.

The most difficult thing among all these stuff is to **get all necessary data efficiently**. Actually that  is *two things*: 1) get all the data 2) make it efficient. At the very last I get most of these things done, with a overhead of about *1us* for every syscall intercepted. That is pretty cool, and this performance is nearly the same with that in Google's [Dapper](https://research.google.com/pubs/pub36356.html) system.  You can find more details about the implementation in the [unfinished paper](../pub/km.pdf) I wrote earlier.

Another cool thing is that we made a tool called *hotpatcher* that can plug a *dynamic shared object* (IOW, a *.so* file) into a *running* process, such that we can deploy the whole system without reboot. This work was based on the [*hotpatch project*](https://github.com/vikasnkumar/hotpatch) from [*SelectiveIntellect*](https://www.selectiveintellect.net/open-source-products/). Based on their work, we make a few improvements, which helps to ensure that at the time of hotpatching the processes should not crush. This is a very important guarantee because our system will get deployed on production environment. Unfortunately I didn't have enough time to finish all the work before my internship ends. There are still a lots of work left to be done.  I just couldn't get clear about all the knowledge about the dynamic linker. The specification is unclear. their code is unclear. It is usually a mess when the dynamic linker is involved, and sometimes you have to read/write assembly to get things work. I was very sorry about that.

Anyway, I really enjoyed my internship there. I learn new things everyday. Thanks to all the friends!

Lately I wrote a paper on that subject. Since I didn't finish all my work, that paper is still in a alpha state. I did intend to continue that project after my internship, but I lost all the source code and relative material a few days ago due to a disk failure ... I have been upset for a long time. Now I decide to put it here ([link](../pub/km.pdf)), without source code. It cover some techniques we used in that project. Hopefully that will be useful to someone. (Please ignore section 6 and 7)